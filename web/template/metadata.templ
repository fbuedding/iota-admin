package template

templ MetadataTemplate() {
	<template id="metadata-template">
		<div class="join pt-5 w-full">
			<input
 				class="input input-bordered join-item w-full"
 				id="name-input"
 				placeholder="Name"
 				required
			/>
			<input
 				id="type-input"
 				name="${id}[${index}].metadata[${count}].type"
 				class="input input-bordered join-item w-full"
 				placeholder="Type"
 				required
			/>
			<input
 				id="value-input"
 				name="${id}[${index}].metadata[${count}].value"
 				class="input input-bordered join-item w-full"
 				placeholder="Value"
 				required
			/>
		</div>
	</template>
  @MetadataScript()
}

script MetadataScript() {
  // Create a class for the element
  class Metadata extends HTMLElement {
    static formAssociated = true;
    static observedAttributes = ["kind", "index"];

    constructor() {
      // Always call super first in constructor
      super();
      this.internals_ = this.attachInternals();
    }

    connectedCallback() {
      let template = document.getElementById("metadata-template");
      this.appendChild(template.content.cloneNode(true));

      if(!(this.hasAttribute("kind") && this.hasAttribute("index"))){
        throw("Missing Attributes")
      }

      this.kind = this.getAttribute("kind");
      this.index = this.getAttribute("index");
      
      this.nameInput = this.querySelector("#name-input");
      this.nameInput.onchange = (event) => { this.onNameChange(event) };

      this.typeInput = this.querySelector("#type-input");
      this.valueInput = this.querySelector("#value-input");
    }

    disconnectedCallback() {}

    adoptedCallback() {}

    attributeChangedCallback(name, oldValue, newValue) {}

    onNameChange(event){
      const value = event.target.value;

      this.typeInput.name =`${this.kind}[${this.index}].metadata[${value}].type`; 
      this.valueInput.name =`${this.kind}[${this.index}].metadata[${value}].value`; 
    }

  }

  customElements.define("metadata-input", Metadata);

}
